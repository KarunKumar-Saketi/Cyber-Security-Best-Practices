<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background: #C2BFB0;
      padding: 30px 5%;
    }

    .header {
      padding: 10px;
      font-size: 30px;
      text-align: center;
      background: white;
      margin-bottom: 20px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
    }

    .leftcolumn {
      flex: 1 1 100%;
      line-height: 2.0;
    }

    .card {
      background-color: white;
      padding: 20px;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    pre {
      background: #f4f4f4;
      padding: 10px;
      overflow-x: auto;
      border-radius: 6px;
    }

    /* Responsive Tweaks */
    @media screen and (max-width: 768px) {
      body {
        padding: 20px 15px;
      }

      .header {
        font-size: 24px;
      }

      .card {
        padding: 16px;
      }

      pre {
        font-size: 14px;
      }
    }

    @media screen and (max-width: 480px) {
      .header {
        font-size: 20px;
      }

      .card {
        padding: 14px;
      }

      pre {
        font-size: 13px;
      }
    }
  </style>
</head>

<body>
  <div class="row">
    <div class="leftcolumn">
        <div class="card">
        <h1 style="text-align: center;">Best Cyber Security Practices</h1>
        <h2>1. Implementing security headers for Web application</h2>
        <h3>üìå What is Content Security Policy (CSP)?</h3>
        <p>Content Security Policy (CSP) is a security feature that helps prevent Cross-Site Scripting (XSS),
          clickjacking, and other code injection attacks by controlling which resources (scripts, styles, images, etc.)
          the browser is allowed to load and execute.</p>
        <p>It is implemented using the Content-Security-Policy HTTP response header.</p>
        <p>‚úÖ What is the Use of CSP?</p>
        <p>The main purposes of CSP include:</p>
        <p>1. Prevent XSS attacks by blocking inline scripts or scripts from untrusted sources.</p>
        <p>2. Restrict resource loading (e.g., only allow scripts from your domain or trusted CDNs).</p>
        <p>3. Reduce attack surface by allowing developers to whitelist only necessary resources.</p>
        <h3>‚ö†Ô∏è What is the Impact if CSP is Not Implemented?</h3>
        <p>Without CSP:</p>
        <p>Your app is vulnerable to XSS attacks, where malicious scripts can run in the browser.</p>
        <p>Attackers may steal cookies, session tokens, or impersonate users.</p>
        <p>May allow injection of unauthorized third-party content, like malicious ads or trackers.</p>
        <p> Increases the risk of data leakage or phishing via trusted UI.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>1. Implement a strong CSP policy.</p>
        <p>2. Avoid inline JavaScript and use external scripts with nonce or hash.</p>
        <p>3. Remove unsafe directives like unsafe-inline, unsafe-eval.</p>
        <p>4. Use CSP reporting to monitor violations via report-Uri or report-to.</p>
        <h3>üöÄ How to Implement CSP in a React.js Application?</h3>
        <p>React itself is frontend ‚Äî CSP is set via server (Node.js, Express, Nginx, Apache, etc.). However, you can structure your app to comply with CSP and 
          set the header from your server.</p>
        <h4>‚úÖ Step-by-Step Implementation (Example with Express.js):</h4>
        <pre>
          bash

          npm install helmet
        </pre>
        <pre>
          js

          const express = require('express');
          const helmet = require('helmet');

          const app = express();

          app.use(
            helmet. contentSecurityPolicy({
              directives: {
                defaultSrc: ["'self"],
                scriptSrc: ["'self", 'https://trusted.cdn.com'],
                styleSrc: ["'self", 'https://fonts.googleapis.com'],
                fontSrc: ["'self", 'https://fonts.gstatic.com'],
                imgSrc: ["'self", 'data:', 'https://image.example.com'],
                connectSrc: ["'self", 'https://api.example.com'],
                objectSrc: ["'none'"],
                upgradeInsecureRequests: [],
              },
            })
          );

          app.use(express.static('build')); //React build folder
          app.listen(3000, () => {
            console.log('Server running on http://localhost:3000');
          });
        </pre>
        <h3>üß† React Best Practices for CSP</h3>
        <p>1. Avoid inline styles/scripts ‚Äì use external files.</p>
        <p>2. Use dangerouslySetInnerHTML sparingly ‚Äì it can break CSP and invite XSS.</p>
        <p>3. Use React Helmet to help manage meta tags, but remember headers are best set server-side.</p>
        <h4>Example CSP Header</h4>
        <p>Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; style-src 'self'</p>
        <h3>üß™ Testing and Validation</h3>
        <p>Use browser dev tools ‚Üí Console ‚Üí CSP errors.</p>
        <p>Use Google CSP Evaluator: https://csp-evaluator.withgoogle.com/</p>
        <p>Use report-uri or report-to to log violations.</p>

        <h3>üõ°Ô∏è What is X-Frame-Options?</h3>
        <p>X-Frame-Options is an HTTP response header that prevents your website from being embedded in an "iframe" on
          other domains. This protects against clickjacking attacks.</p>
        <h3>‚úÖ What Is the Use of It?</h3>
        <p>Clickjacking occurs when a malicious website embeds your site in an invisible "iframe" and tricks users into
          clicking buttons or links without knowing. This can lead to:</p>
        <p>Unintended actions (e.g. transferring funds, deleting content)</p>
        <p>Credential theft</p>
        <p>UI redressing</p>
        <p>X-Frame-Options blocks this by controlling how/if your site can be framed.</p>
        <h3>‚ö†Ô∏è What is the Impact If the Header Is Missing?</h3>
        <p>Without X-Frame-Options, your app is vulnerable to:</p>
        <p>Clickjacking attacks</p>
        <p>UI redressing threats</p>
        <p>Trust erosion ‚Äî users might unknowingly interact with malicious overlays</p>
        <p>Regulatory non-compliance (e.g. OWASP Top 10: A5 ‚Äì Security Misconfiguration)</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>Set the X-Frame-Options header to DENY or SAMEORIGIN.
        <p>Use Content-Security-Policy (CSP) with the frame-ancestors directive for more modern control (CSP is more flexible and the preferred long-term 
          solution).</p>
        <p>Avoid using "iframe" to load sensitive interfaces unless absolutely necessary.</p>
        <h3>üöÄ How to Implement the Header Using React.js?</h3>
        <p>React is a frontend library, so security headers like X-Frame-Options must be configured on the server that serves the React app.</p>
        <h4>‚úÖ Example with Express.js + Helmet</h4>
        <p>Install Helmet (security middleware):</p>
        <pre>
          bash

          npm install helmet
        </pre>
        <p>Add this to your server code (e.g., server.js):</p>
        <pre>
          js

          const express = require('express');
          const helmet = require('helmet');

          const app = express();

          // Add X-Frame-Options header
          app.use(helmet.frameguard({ action: 'deny'})); //or use 'sameorigin'

          app.use(express.static('build')); //Server React build folder

          app.listen(3000, () => {
            console.log('Server running on http://localhost:3000');
          });

        
        </pre>
        <p>This will send this HTTP header in every response:</p>
        <pre>
          http

          X-Frame-Options: DENY
        </pre>
        <h3>‚öõÔ∏è React Build with Static Hosting (e.g. NGINX)</h3>
        <p>In NGINX,, add this to your config</p>
        <pre>
          nginx

          add_header X-Frame-Options "DENY";
        </pre>
        <h4>Use CSP Instead (Modern Replacement)</h4>
        <p>Use this Content-Security-Policy header as an alternative to X-Frame-Options:</p>
        <pre>
          http

          Content-Security-Policy: frame-ancestors 'none'; // Same as DENY
        </pre>
        <p>OR:</p>
        <pre>
          http

          Content-Security-Policy: frame-ancestors 'self'; // Same as sameorigin
        </pre>
        <h3>üîó Reference Links:</h3>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options</a></p>
        <p><a href="https://owasp.org/www-community/attacks/Clickjacking">https://owasp.org/www-community/attacks/Clickjacking</a></p>
        <p><a href="https://helmetjs.github.io/docs/frameguard/">https://helmetjs.github.io/docs/frameguard/</a></p>

      <h3>üõ°Ô∏è What is X-Content-Type-Options?</h3>
      <p>X-Content-Type-Options is an HTTP security header that prevents browsers from MIME-sniffing a response away from the declared content-type.</p>
      <p>It is used to force the browser to respect the Content-Type declared by the server, thus preventing it from interpreting files as something else.</p>
      <h3>‚úÖ What Is the Use of It?</h3>
      <p>Helps prevent MIME type confusion attacks where a browser tries to ‚Äúguess‚Äù the type of a file and executes it as something else (e.g., executing a script when it should be treated as plain text).</p>
      <p>Protects against cross-site scripting (XSS) and drive-by downloads by ensuring that content is interpreted strictly as the intended type.</p>
      <p>Improves overall content security by eliminating ambiguity on how resources are handled.</p>
      <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
      <p>Browsers may mime-sniff responses and treat non-executable resources as executable, opening up your app to XSS.</p>
      <p>Attackers can exploit this to run malicious scripts or load unsafe content.</p>
      <p>Potential security vulnerabilities in older browsers or those that support content sniffing.</p>
      <p>Increased risk of client-side injection attacks.</p>
      <h3>üõ†Ô∏è Remediation of the Issue</h3>
      <p>Add the header:</p>
      <pre>
        http

        X-Content-Type-Options: nosniff
      </pre>
      <p>Ensure your server is sending correct Content-Type headers for all resources.</p>
      <p>Avoid serving files with ambiguous or incorrect MIME types.</p>  
      <p>Use security middleware or server configuration to automate this header.</p>
      <h3>üöÄ How to Implement the Header Using React.js?</h3>
      <p>Since React is frontend-only, this header must be set by the server serving your React app.</p>
      <p>Example: Using Express.js with Helmet</p>
      <pre>
        bash

        npm install helmet
      </pre>
      <pre>
        js

          const express = require('express');
          const helmet = require('helmet');

          const app = express();

          app.use(helmet());

          app.use(express.static('build'));

          app.listen(3000, () =>{
            console.log('Server running on http://location:3000');
          }); 
      </pre>
      <p>This automatically adds:</p>
      <pre>
        http

         X-Content-Type-Options: nosniff
      </pre>
      <h4>If you manully want to set it (in Express):</h4>
      <pre>
        js

        app.use((req, res, next) => {
          res.setHeader('X-Content-Type-Options', 'nosniff');
          next();
        })
      </pre>
      <h4>Using NGINX to set the header:</h4>
      <pre>
        nginx

        add_header X-Content-Type-Options nosniff;
      </pre>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options</a></p>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html#x-content-type-options">https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html#x-content-type-options</a></p>
      <p><a href="https://helmetjs.github.io/">https://helmetjs.github.io/</a></p>

      <h3>üõ°Ô∏è What is Strict-Transport-Security?</h3>
      <p>The Strict-Transport-Security (HSTS) header is an HTTP response header that enforces browsers to only interact with your website over HTTPS (secure connection).</p>
      <p>It tells browsers to automatically convert all HTTP requests to HTTPS for a specified time, preventing insecure HTTP access.</p>
      <h3>‚úÖ What Is the Use of It?</h3>
      <p>Prevents <b>SSL/TLS stripping attacks</b> where attackers downgrade HTTPS to HTTP and intercept traffic.</p>
      <p>Ensures <b>all communications are encrypted</b>, protecting data integrity and confidentiality.</p>
      <p>Improves overall <b>website security</b> by forcing HTTPS usage on clients.</p>
      <p>Helps browsers <b>remember your site is HTTPS only</b> (even if users type http://).</p>
      <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
      <p>Users might access the site over <b>unencrypted HTTP</b>, exposing data to interception or manipulation.</p>
      <p>Vulnerable to <b>man-in-the-middle (MITM)</b> attacks where attackers downgrade connections.</p>
      <p>Users can be redirected to unsafe versions of your site without knowing.</p>
      <p>Loss of user trust and potential regulatory compliance issues.</p>
      <h3>üõ†Ô∏è Remediation of the Issue</h3>
      <p>Add the Strict-Transport-Security header with recommended parameters:</p>
      <p>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</p>
      <p>max-age=31536000 ‚Äî enforce HTTPS for 1 year (in seconds).</p>
      <p>includeSubDomains ‚Äî apply rule to all subdomains.</p>
      <p>preload ‚Äî optional, for inclusion in browser preload lists (submit at https://hstspreload.org/).</p>
      <h3>üöÄ How to Implement the Header Using React.js?</h3>
      <p>Since React is frontend, this header is set on the server or CDN that serves your React app.</p>
      <p>Example: Using Express.js with Helmet</p>
      <pre>
        bash

        npm install helmet
      </pre>
      <pre>
        js

          const express = require('express');
          const helmet = require('helmet');

          const app = express();

          app.use(
            helmet.hsts({
              maxAge: 31536000,
              includeSubDomains: true,
              preload: true,
            })
          );

          app.use(express.static('build'));

          app.listen(3000, () =>{
            console.log('Server running on http://location:3000');
          }); 
      </pre>
      <p>This will send:</p>
      <pre>
        http

        Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
      </pre>
      <p>Example: NGINX</p>
      <pre>
        nginx

        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
      </pre>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security</a></p>
      <p><a href="https://owasp.org/www-project-secure-headers/#strict-transport-security">https://owasp.org/www-project-secure-headers/#strict-transport-security</a></p>
      <p><a href="https://helmetjs.github.io/docs/hsts/">https://helmetjs.github.io/docs/hsts/</a></p>
      
      <h3>üõ°Ô∏è What is Cache-Control?</h3>
      <p>Cache-Control is an HTTP header used to specify caching policies for browsers and intermediate caches (like proxies or CDNs). It controls how, and for 
        how long, responses are cached to improve performance and reduce server load.</p>
      <h3>‚úÖ What Is the Use of It?</h3>
      <p>Controls whether responses can be cached, by whom, and for how long.</p>
      <p>Helps improve page load speed by reusing cached content.</p>
      <p>Ensures clients get fresh or stale content based on your policy.</p>
      <p>Manages cache validation and revalidation.</p>
      <p>Controls privacy by preventing sensitive data caching.</p>
      <h3>‚ö†Ô∏è Impact if the Application Does NOT Implement this Header</h3>
      <p>Browsers and proxies might cache sensitive data improperly, risking data leaks.</p>
      <p>Stale or outdated content may be served to users, causing confusion or errors.</p>
      <p>Increased load on your backend servers due to unnecessary repeated requests.</p>
      <p>Potential security risks, especially if private data is cached publicly.</p>
      <p>Lack of caching may result in poor performance and slower page loads.</p>
      <h3>üõ†Ô∏è Remediation of the Issue</h3>
      <p>Set appropriate Cache-Control headers on the server or CDN.</p>
      <p>Use long max-age values for static assets with cache busting (e.g., hashed filenames).</p>
      <p>Use no-cache or no-store for sensitive or dynamic data.</p>
      <p>Regularly review caching policies to match app requirements.</p>
      <h3>üöÄ How to Implement the Cache-Control header Using React.js?</h3>
      <p>React apps are frontend and do not control HTTP headers directly; these must be set on the server or CDN serving your React app files:</p>
      <p>1. If using a static file server (Nginx, Apache):</p>
      <p>Example for Nginx:</p>
      <pre>
        nginx

        location /static/ {
          add_header Cache-Control "public, max-age=31536000, immutable";
        }

        location /index.html {
          add_header Cache-Control "no-cache";
        }

      </pre>
      <p>2. If serving React with Node.js/Express:</p>
      <pre>
        js

        app.use(express.static('build', {
          setHeaders: (res, path) => {
            if (path.endsWith('.html')) {
              res.setHeader('Cache-Control', 'no-cache');
            } else {
              res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
            }
          }
        }));
      </pre>
      <p>3. If using a CDN or hosting platform (Netlify, Vercel, CloudFront):</p>
      <p>Set cache-control headers in the platform‚Äôs configuration or rules.</p>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control</a></p>
      <p><a href="https://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header">https://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header</a></p>

      </div>



      <div class="card">
        <h2>2. Unrestricted File Upload</h2>
        <h3>üìå What is Unrestricted File Upload?</h3>
        <p>Unrestricted File Upload is a security vulnerability where an application allows users to upload files
          without properly validating or restricting the
          file types, sizes, or content. This can enable attackers to upload malicious files (e.g., web shells, scripts,
          executables) that could be executed on
          the server or delivered to other users, potentially compromising the system.</p>
        <h3>‚úÖ How is File Validation Used?</h3>
        <p>File validation is the process of checking uploaded files to ensure they conform to expected criteria such as:</p>
        <p><b>File type validation:</b> Confirming the file extension and MIME type match allowed types (e.g., .jpg, .png, .pdf).</p>
        <P><b>File size validation:</b> Enforcing size limits to prevent resource exhaustion.</P>
        <P><b>File content validation:</b> Optionally inspecting file contents to detect malicious code.</P>
        <P><b>Filename sanitization:</b> Removing or restricting harmful characters to prevent path traversal or injection.</P>
        <P><b>Storage location control:</b> Ensuring uploaded files are stored in secure, non-executable directories.</P>
        <h3>‚ö†Ô∏è Impact if File Validation Is Not Implemented</h3>
        <p><b>Remote Code Execution (RCE):</b> Attackers can upload and execute malicious scripts on the server.</p>
        <p><b>Malware Distribution:</b> The system can become a source for spreading malware.</p>
        <p><b>Denial of Service (DoS):</b> Uploading very large or numerous files can exhaust server resources.</p>
        <p><b>Data Breach or Defacement:</b> Malicious files may lead to data leaks or unauthorized site modification.</p>
        <p><b>Unauthorized Access:</b> Exploiting uploaded files to escalate privileges.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>1. Strictly validate file type and MIME type to accept only known safe formats.</p>
        <p>2. Enforce file size limits to control resource use.</p>
        <p>3. Sanitize file names or generate safe random names.</p>
        <p>4.Store uploaded files outside the web root to prevent direct execution.</p>
        <p>5. Scan uploaded files with antivirus/malware scanners if possible.</p>
        <p>6. Implement authentication and authorization for upload endpoints.</p>
        <p>7. Log upload activity to detect suspicious behavior.</p>
        <h3>üöÄ How to Implement File Upload Validation and Best Practices</h3>
        <p><b>Validate File Type and MIME Type:</b> Check both the file extension and the MIME type (provided by the client or verified on server side).</p>
        <p><b>Limit File Size:</b> Reject files exceeding the defined maximum size.</p>
        <p><b>Sanitize Filenames:</b> Remove special characters or use generated unique names (e.g., UUIDs).</p>
        <p><b>Store Files Securely:</b> Place uploaded files in directories not directly accessible or executable by the web server.</p>
        <p><b>Scan for Malware:</b> Use antivirus APIs or tools for scanning uploaded files.</p>
        <p><b>Use HTTPS:</b> Secure upload process against interception.</p>
        <p><b>Set Proper Permissions:</b> Ensure upload folders have restricted permissions (no execute).</p>
        <p><b>Monitor and Log Uploads:</b> Keep track of file uploads for auditing.</p>
        <h2>Example (Node.js + Multer):</h2>
        <pre>
            const multer = require('multer');
            const path = require('path');

            const storage = multer.diskStorage({
              destination: (req, file, cb) => {
              cb(null, 'uploads/'); // Store outside web root if possible
              },
            filename: (req, file, cb) => {
            const ext = path.extname(file.originalname);
            const safeName = Date.now() + '-' + Math.round(Math.random() * 1E9) + ext;
            cb(null, safeName);
              }
            });
            const fileFilter = (req, file, cb) => {
            const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
              if (allowedTypes.includes(file.mimetype)) {
                cb(null, true);
              } else {
                cb(new Error('Invalid file type'), false);
              }
            };

            const upload = multer({
              storage,
              limits: { fileSize: 5 * 1024 * 1024 }, // 5 MB limit
              fileFilter
          });
        </pre>
        <h3>üîó Reference Links:</h3>
        <p><a href="https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload">https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload</a></p>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST#uploading_files">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST#uploading_files</a></p>
        <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html</a></p>

      </div>


     <div class="card">
        <h2>3. Implement Secure & HTTPOnly Flags</h2>
        <h3>üìå What is the Secure Flag?</h3>
        <p>The Secure flag is a cookie attribute that instructs browsers to only send the cookie over HTTPS connections. When this flag is set, the cookie is
          never transmitted over unencrypted HTTP, protecting it from being intercepted by attackers in man-in-the-middle (MITM) attacks.</p>
        <h3>‚úÖ How is File Validation Used?</h3>
        <p>The Secure flag is set by the server when creating cookies, especially session cookies that identify authenticated users.</p>
        <p>Example HTTP response header:</p>
        <p><b>Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict</b></p>
        <p>Secure means the browser will only send this cookie on HTTPS requests.</p>
        <p>It helps protect cookies from exposure on insecure networks.</p>
        <h3>‚ö†Ô∏è Impact if the Secure flag is not implemented on session cookies</h3>
        <p>1. Cookie theft via MITM attacks: On unsecured HTTP connections, attackers can sniff cookies and hijack user sessions.</p>
        <p>2. Session hijacking: Attackers can impersonate legitimate users, leading to account compromise.</p>
        <p>3. Loss of confidentiality and integrity: Sensitive data in cookies can be intercepted and manipulated.</p>
        <p>4. Non-compliance: Failing to set Secure on session cookies may violate security best practices and regulations.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>Always set the Secure flag on cookies that contain sensitive data, especially session cookies.</p>
        <p>Ensure your website uses HTTPS exclusively to benefit from the Secure flag.</p>
        <p>Combine Secure with HttpOnly (prevents client-side scripts from accessing cookies) and SameSite attributes to further harden cookie security.</p>
        <p>Review cookie handling in your backend and frontend to confirm the Secure flag is applied.</p>
        <h3>üöÄ How to implement the Secure flag in a React application?</h3>
        <p>React runs in the browser and does not directly control cookie attributes like Secure; these are set by the server issuing the cookies.</p>
        <h2>Steps to implement:</h2>
        <p>1. On the server (Node.js, Express example):</p>
        <pre>
            js

            res.cookie('sessionId', sessionId, {
              httpOnly: true,
              secure: true,        // Secure flag set here
              sameSite: 'Strict',
              maxAge: 3600000
            });
          </pre>
        <p>2. When using client-side cookies (less recommended for session cookies):</p>
        <p>Use js-cookie or similar libraries, but the Secure flag can only be set by the server.</p>
        <p>3. Ensure your app is served over HTTPS, so browsers send Secure cookies.</p>
        <p>4. In React, access to cookies (e.g., via document.cookie) will automatically respect these flags.</p>
        <div class="fakeimg" style="height:200px;">Image</div>
        <h3>üîó Reference Links:</h3>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies</a></p>
        <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-secure-flag">https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-secure-flag</a></p>
        <p><a href="https://owasp.org/www-community/controls/SecureFlag">https://owasp.org/www-community/controls/SecureFlag</a></p>
        <p><a href="https://expressjs.com/en/api.html#res.cookie">https://expressjs.com/en/api.html#res.cookie</a></p>

        <h3>üìå What is the HTTPOnly Flag?</h3>
        <p>The HTTPOnly flag is a cookie attribute that prevents client-side scripts (like JavaScript) from accessing the cookie. This helps protect
          cookies‚Äîespecially session cookies‚Äîfrom cross-site scripting (XSS) attacks where malicious scripts try to steal cookies.</p>
        <h3>‚úÖ How is the HTTPOnly flag used?</h3>
        <p>When a server sets a cookie, it can add the HttpOnly attribute in the Set-Cookie header:</p>
        <p><b>Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict</b></p>
        <p>This tells browsers not to expose the cookie to client-side APIs such as document.cookie.</p>
        <p>The cookie is still sent with every HTTP request to the server but is invisible to JavaScript.</p>
        <h3>‚ö†Ô∏è Impact if the HTTPOnly flag is not implemented on session cookies</h3>
        <p>1. XSS attacks become more dangerous: Malicious JavaScript can read the cookie and send it to attackers.</p>
        <p>2. Session hijacking: Attackers can steal session cookies and impersonate users.</p>
        <p>3. Increased risk of account compromise: Without protection, session cookies are vulnerable.</p>
        <p>4. Violation of security best practices: Leaving out this flag weakens cookie security posture.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>Always set the HttpOnly flag on cookies containing sensitive information, especially session cookies.</p>
        <p>Combine with Secure and SameSite flags for better security.</p>
        <p>Fix any XSS vulnerabilities in your application to reduce overall risk.</p>
        <p>Set cookie flags on the server side when issuing cookies.</p>
        <h3>üöÄ How to implement the HTTPOnly flag in a React application?</h3>
        <p>React is a frontend framework and does not control cookie flags directly because these are set by the server.</p>
        <h2>Typical approach:</h2>
        <p>1. Set HttpOnly flag on the server side when issuing cookies.</p>
        <p>Example in Node.js/Express</p>
        <pre>
            js

            res.cookie('sessionId', sessionId, {
              httpOnly: true,
              secure: true,        // HttpOnly flag set here
              sameSite: 'Strict',
              maxAge: 3600000
            });
          </pre>
        <p>2. On the React side:</p>
        <p>You cannot read HttpOnly cookies using JavaScript (document.cookie).</p>
        <p>Cookies are automatically included in HTTP requests by the browser (e.g., via fetch or axios) if the request
          is to the same origin or with proper CORS settings.</p>
        <p>Ensure requests are made with credentials when needed:</p>
        <pre>
            js

            fetch('/api/data', {
              credentials: 'include'
            });
          </pre>
        <div class="fakeimg" style="height:200px;">Image</div>
        <h3>üîó Reference Links:</h3>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#restrict_access_to_cookies</a></p>
        <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-httponly-flag">https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#use-the-httponly-flag</a></p>
        <p><a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a></p>
        <p><a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a></p>

      </div>

    <div class="card">
        <h2>4. Sensitive Information in Local Storage</h2>
        <h3>üìå What Happens When an Application Stores Sensitive Information in Local Storage?</h3>
        <p>Local storage is a web storage mechanism that allows websites to store data in the user's browser. It's
          accessible through JavaScript and persists even
          after the browser is closed.</p>
        <p>When sensitive data (like authentication tokens, passwords, personal user data, or payment info) is stored
          here, it becomes vulnerable because:</p>
        <p><b>Accessible by any JavaScript running on the page:</b> This means if an attacker manages to inject
          malicious JavaScript (e.g., via XSS), they can easily access local storage data.</p>
        <p><b>No expiration mechanism:</b> Data stays until explicitly deleted, increasing the risk if the device is
          shared or compromised.</p>
        <p><b>No encryption:</b> Data is stored as plain text, so anyone with access to the device/browser profile can
          read it.</p>
        <h3>‚ö†Ô∏è Impact of Storing Sensitive Information in Local Storage</h3>
        <p><b>Cross-Site Scripting (XSS) attacks:</b> If your site is vulnerable to XSS, an attacker can steal tokens or
          sensitive info from local storage.</p>
        <p><b>Data theft on shared or stolen devices:</b> Anyone with access to the device/browser profile can retrieve
          the sensitive data.</p>
        <p><b>Session hijacking:</b> Stolen tokens or credentials can allow attackers to impersonate the user.</p>
        <p><b>Non-compliance:</b> Violates security best practices and compliance standards (like GDPR, PCI DSS, HIPAA).
        </p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p>1. Avoid storing sensitive data in local storage entirely.</p>
        <p>2. Use secure, httpOnly cookies for sensitive tokens:</p>
        <p>Cookies marked as HttpOnly are inaccessible via JavaScript, preventing access from XSS attacks.</p>
        <p>Use the Secure flag to ensure cookies are sent only over HTTPS.</p>
        <p>Use the SameSite attribute to prevent CSRF attacks.</p>
        <p>3. Implement strong Content Security Policy (CSP): Mitigates XSS by restricting the sources of executable
          scripts.</p>
        <p>4. Use proper authentication mechanisms: Use short-lived access tokens with refresh tokens stored securely.
        </p>
        <p>5. Encrypt sensitive data if it must be stored client-side: But preferably avoid this approach.</p>
        <p>6. Clear sensitive data from storage on logout or session expiration.</p>
        <h3>üöÄ How to Remove Sensitive Information and Best Way to Pass It in ReactJS</h3>
        <p>Remove sensitive info from local storage:</p>
        <pre>
        js

        localStorage.removeItem('sensitive_key');
        // or clear all local storage
        localStorage.clear();

      </pre>
      <p><b>Best practice for handling tokens in React:</b></p>
      <p>Store tokens in secure, httpOnly cookies (set by your backend).</p>
      <p>Use React context or state management (Redux, React Context API) to hold sensitive info during the session.</p>
      <p>Pass tokens via cookies automatically included in HTTP requests.</p>
      <p>Use libraries like axios with withCredentials: true to send cookies.</p>
      <div class="fakeimg" style="height:200px;">Image</div>
      <h4>Example:</h4>
      <p>Backend sets cookie:</p>
      <pre>
        http

        Set-Cookie: token=abc123; HttpOnly; Secure; SameSite=Strict
      </pre>
      <p>React frontend makes API calls without handling the token explicityl:</p>
      <pre>
        js

        axios.get('/api/protected', { withCredentials: true });
      </pre>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage">https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage</a></p>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#session-management">https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#session-management</a></p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API  </a></p>
      </div>

      <div class="card">
        <h2>5. Components with Known Vulnerabilities</h2>
        <h3>üìå What Happens When the Application Uses Components with Known Vulnerabilities?</h3>
        <p>When an application relies on third-party libraries, frameworks, or components that have known security vulnerabilities, it exposes itself to various 
          risks. These vulnerabilities could be due to bugs, design flaws, or security weaknesses that have already been discovered and documented publicly.</p>
        <p>Using such vulnerable components means:</p>
        <p>Attackers can exploit these known flaws to compromise the application.</p>
        <p>The application inherits the security weaknesses of its dependencies.</p>
        <p>It increases the risk of data breaches, unauthorized access, or application malfunction.</p>
        <h3>‚ö†Ô∏è Impact of Using Components with Known Vulnerabilities</h3>
        <p><b>Data compromise:</b> Sensitive information may be leaked or stolen.</p>
        <p><b>Remote code execution:</b> Vulnerabilities can allow attackers to run arbitrary code.</p>
        <p><b>Denial of service:</b> Exploiting vulnerabilities to crash or slow down the application.</p>
        <p><b>Privilege escalation:</b> Attackers gain unauthorized privileges.</p>
        <p><b>Loss of trust & reputation:</b> Users lose confidence in the app‚Äôs security.</p>
        <p><b>Non-compliance:</b> Failure to meet security standards and regulations.</p>
        <p><b>Chain reaction:</b> Vulnerabilities in dependencies can propagate through your supply chain.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p><b>1. Regularly scan and monitor dependencies:</b></p>
        <p>Use automated tools like Dependabot, Snyk, npm audit, OSS Index, or WhiteSource to detect vulnerable packages.</p>
        <p><b>2. Keep dependencies up to date:</b></p>
        <p>Apply security patches and updates promptly.</p>
        <p><b>3. Use trusted and well-maintained libraries:</b></p>
        <p>Prefer popular, actively maintained components with good security records.</p>
        <p><b>4. Minimize dependencies:</b></p>
        <p>Only include necessary libraries to reduce the attack surface.</p>
        <p><b>5. Audit third-party code:</b></p>
        <p>Review critical dependencies manually or with code scanners.</p>
        <p><b>6. Establish a dependency management policy:</b></p>
        <p>Enforce rules around updating and vetting dependencies.</p>
        <p><b>7. Consider alternatives or forks:</b></p>
        <p>If a library is abandoned and vulnerable, consider migrating to a safer alternative or maintaining a patched fork.</p> 
      <h3>üîó Reference Links:</h3>
      <p><a href="https://owasp.org/www-project-dependency-check/">https://owasp.org/www-project-dependency-check/</a></p>
      <p><a href="https://owasp.org/www-project-software-component-verification-standard/">https://owasp.org/www-project-software-component-verification-standard/</a></p>
      <p><a href="https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/">https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/</a></p>
      </div>

      <div class="card">
        <h2>6. User input validation</h2>
        <h3>üìå What Happens When the Application Is Not Validating User Input Data?</h3>
        <p>When an application fails to <b>validate user input</b>, it means it accepts data from users without checking if the data is in the expected format, type, 
          length, or content. This opens the door to many issues because malicious or malformed data can enter your system.</p>
        <h3>‚ö†Ô∏è Impact of Not Validating User Input</h3>
        <p><b>Injection Attacks:</b>  Like SQL Injection, Command Injection, or NoSQL Injection where attackers inject malicious queries or commands.</p>
        <p><b>Cross-Site Scripting (XSS):</b> Attackers inject malicious scripts into web pages viewed by other users.</p>
        <p><b>Buffer Overflow:</b>  Improper input size handling can crash or compromise the system.</p>
        <p><b>Authentication bypass:</b> If inputs like usernames or tokens aren‚Äôt properly validated, attackers might bypass controls.</p>
        <p><b>Application crashes or unexpected behavior:</b> Caused by malformed or unexpected input.</p>
        <p><b>Data corruption:</b> Invalid data can corrupt your database or internal logic.</p>
        <p><b>Security misconfigurations:</b> Inputs might be used in config or system calls, leading to vulnerabilities.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p><b>1. Implement strict input validation</b>on both client and server sides.</p>
        <p><b>2. Validate by type, format, length, and content:</b>Accept only what‚Äôs expected.</p>
        <p><b>3. Use allow-list (whitelist) validation rather than deny-list (blacklist).</b></p>
        <p><b>4. Sanitize inputs:</b>Remove or encode dangerous characters to prevent injections.</p>
        <p><b>5. Use built-in validation libraries or frameworks</b> that are well-maintained.</p>
        <p><b>6. Reject invalid input immediately </b>with meaningful error messages.</p>
        <p><b>7. Perform server-side validation as the ultimate gatekeeper,</b>since client-side validation can be bypassed.</p>
        <p><b>8. Use parameterized queries for database access</b> to avoid injection risks.</p>
        <p><b>9. Encode output to prevent XSS </b>when displaying user input.</p>
      <h3>üöÄ How to Implement Input Validation on User Input Data in ReactJS</h3>
      <h4>Client-Side validation:</h4>
      <p>Use libraries like <b>Formik + Yup, React Hook Form,</b> or manual validation.</p>
      <pre>
        import { useForm } from "react-hook-form";
        import * as yup from "yup";
        import { yupResolver } from "@hookform/resolvers/yup";
        
        const schema = yup.object().shape({
        username: yup.string().required().min(3).max(20),
        email: yup.string().email().required(),
        age: yup.number().positive().integer().required(),
        });
        
        function MyForm() { 
        const { register, handleSubmit, errors } = useForm({
        resolver: yupResolver(schema),
        });
        
        const onSubmit = data => {
        console.log(data);
        };
        
        return (
        <form onSubmit={handleSubmit(onSubmit)}>
          <input {...register("username")} />
          {errors.username && <p>{errors.username.message}</p>}
        
          <input {...register("email")} />
          {errors.email && <p>{errors.email.message}</p>}
        
          <input type="number" {...register("age")} />
          {errors.age && <p>{errors.age.message}</p>}
        
          <input type="submit" />
        </form>
        );
        }
      </pre>
      <h4>Server-Side Validation:</h4>
      <p>Always validate again on the backend with similar strict rules. Use frameworks or libraries based on your backend stack.</p>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html</a></p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation">https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation</a></p>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Prevention_Cheat_Sheet.html</a></p>
      <p><a href="https://react-hook-form.com/get-started/">https://react-hook-form.com/get-started/</a></p>
    </div>

    <div class="card">
        <h2>7. Exposing Server Details</h2>
        <h3>üìå What Happens When the Application Exposes Server Details via Application Errors or Response Headers?</h3>
        <p>When an application reveals server details such as: Server software name and version (e.g., Apache/2.4.41), Framework version, Detailed error stack traces or messages,</p>
        <p>through HTTP response headers or error pages, it unintentionally gives attackers useful information to craft targeted attacks.</p>
        <h3>‚ö†Ô∏è Impact of Exposing Server Details</h3>
        <p><b>Facilitates targeted attacks:</b> Attackers can identify vulnerabilities specific to the server or framework version.</p>
        <p><b>Increases risk of automated scanning and exploitation:</b> Bots often scan for known vulnerable versions.</p>
        <p><b>Information disclosure:</b> Sensitive internal details can leak, which might help in privilege escalation.</p>
        <p><b>Helps attackers bypass security measures: </b>Knowing exact software makes it easier to exploit known weaknesses.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p><b>1. Suppress detailed error messages on production environments:</b> Show generic, user-friendly error pages instead.</p>
        <p><b>2. Remove or modify server response headers that reveal server info:</b></p>
        <p>Common headers to remove or hide:</p>
        <p>Server</p>
        <p>X-Powered-By</p>
        <p><b>3. Implement centralized error handling:</b></p>
        <p>Log detailed errors internally (not exposed to users).</p>
        <p>Present generic messages to clients.</p>
        <p><b>4. Configure your web server and application server to hide version info:</b></p>
        <p>Many servers have config options for this.</p>
        <p><b>5. Perform regular security scans</b> to detect information disclosure.</p>
      <h3>üöÄ How to Implement Proper Error Pages</h3>
      <p>Create custom error pages for HTTP status codes like 404, 500, 401, etc.</p>
      <p>In React apps, use error boundaries for UI errors and fallback pages for route errors.</p>
      <p>On the backend or web server, configure custom static error pages that do not reveal stack traces or sensitive info.</p>
      <h4>Example (Express.js):</h4>
      <pre>
        js

        app.use((err, req, res, next) => {
          console.error(err);  // Log internally
          res.status(500).send("Something went wrong. Please try again later.");
        });
      </pre>
      <h4>How to Remove Server Version Details in HTTP Responses</h4>
      <p>In Express.js (Node.js):</p>
      <pre>
        js

        app.disable('X-Powered-By');
      </pre>
      <p>In Apache:</p>
      <p>In your Apache config or .htaccess:</p>
      <pre>
        apache

        ServerSignature Off
        ServerTokens Prod
      </pre>
      <p>In Nginx:</p>
      <p>Add to nginx.conf</p>
      <pre>
        nginx

        server_tokens off;
      </pre>
      <p>In IIS:</p>
      <p>Use URLScan or Request Filtering to remove headers.</p>
      <p>Removing Server header entirely (Node.js example):</p>
      <pre>
        js

        app.use((req, res, next) => {
          res.removeHeader("Server");
          next();
        });
      </pre>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html">https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html</a></p>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html</a></p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server</a></p>
      <p><a href="https://expressjs.com/en/advanced/best-practice-security.html#disable-x-powered-by-header">https://expressjs.com/en/advanced/best-practice-security.html#disable-x-powered-by-header</a></p>
    </div>

    <div class="card">
        <h2>8. TLS Cipher Versions</h2>
        <h3>‚úÖ What Is a TLS Cipher?</h3>
        <p>A TLS cipher (cipher suite) is a set of algorithms used during a TLS (Transport Layer Security) handshake to securely:</p>
        <p>Authenticate the server (and optionally the client),</p>
        <p>Negotiate encryption algorithms,</p>
        <p>Encrypt and decrypt data transmitted between client and server.</p>
        <p>A cipher suite includes:</p>
        <p>Key exchange algorithm (e.g., ECDHE),</p>
        <p>Authentication algorithm (e.g., RSA),</p>
        <p>Message authentication code (MAC) algorithm (e.g., SHA256).</p>
        <h4>Example cipher suite:</h4>
        <pre>
          nginx

          TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        </pre>
        <p>Symmetric encryption algorithm (e.g., AES),</p>
        <h3>‚ö†Ô∏è What Is the Impact of TLS 1.0 Ciphers Being Enabled?</h3>
        <p>TLS 1.0 is an <b>obsolete and insecure protocol version</b>(released in 1999). If TLS 1.0 or its cipher suites are enabled:.</p>
        <p><b>Increases risk of automated scanning and exploitation:</b> Bots often scan for known vulnerable versions.</p>
        <p><b>1. üîì Weak encryption</b>can be broken by modern attackers.</p>
        <p><b>2. üß™ Susceptible to attacks</b> like BEAST, POODLE, and downgrade attacks.</p>
        <p><b>3. üö´ Non-compliance</b>with standards such as:</p>
        <p>PCI DSS (prohibits TLS 1.0 since 2018),</p>
        <p>NIST,</p>
        <p>HIPAA,</p>
        <p>ISO 27001.</p>
        <p><b>4. üîÑ Increased attack surface</b> for older cipher suites like:</p>
        <p>RC4, DES, 3DES, MD5-based, and EXPORT-grade ciphers.</p>
        <h3>üõ†Ô∏è Remediation of the Issue</h3>
        <p><b>1. Disable TLS 1.0 and TLS 1.1.</b></p>
        <p><b>2. Enable only TLS 1.2 and TLS 1.3.</b></p>
        <p><b>3. Allow only strong cipher suites,</b> such as:</p>
        <p>TLS 1.2:</p>
        <p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
        <p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</p>
        <p>TLS 1.3:</p>
        <p>Built-in strong ciphers, e.g., TLS_AES_128_GCM_SHA256</p>
      <h3>üîß How to Disable TLS 1.0 Ciphers & Enable Secure Ciphers</h3>
      <h4>‚úÖ On Apache (httpd)</h4>
      <p>Edit httpd.conf or ssl.conf:</p>
      <pre>
        apache

        SSLProtocol -all +TLSv1.2 +TLSv1.3
        SSLCipherSuite HIGH:!aNULL:!MD5:!3DES:!RC4:!SHA1:!SSLv3:!TLSv1:!TLSv1.1
        SSLHonorCipherOrder on
      </pre>
      <h4>‚úÖ On Nginx:</h4>
      <p>Edit nginx.conf:</p>
      <pre>
        nginx

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
        ssl_prefer_server_ciphers on;
      </pre>
      <h4>‚úÖ On Windows(IIS):</h4>
      <p>Use the registry editor or IIS Crypto tool:</p>
      <p>Registry path:</p>
      <pre>
        sql

        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols
      </pre>
      <p>Disable:</p>
      <pre>
        ini

        [TLS 1.0\Server]
        "Enable"=dword:00000000
      </pre>
      <p>Then restart the server.</p>
      <h4>‚úÖ On Node.js(If using HTTPS server):</h4>
      <p>Set secure TLS Options:</p>
      <pre>
        js

        const https = require('https');
        const options = {
          secureOptions:
            require('constants').SSL_OP_NO_TLSv1 |
            require('constants').SSL_OP_NO_TLSv1_1,
          ciphers: 'ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA384',
        };
        https.createServer(options, app).listen(443);
      </pre>
      <h3>üîó Reference Links:</h3>
      <p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html</a></p>
      <p><a href="https://csrc.nist.gov/pubs/sp/800/52/r2/final">https://csrc.nist.gov/pubs/sp/800/52/r2/final</a></p>
      <p><a href="https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls">https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls</a></p>
      <p><a href="https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls">https://blog.pcisecuritystandards.org/migrating-from-ssl-and-early-tls</a></p>
    </div>

    </div>

  </div>
</body>
</html>
